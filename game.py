import jsonimport randomfrom characters import Bookworn, Worker, Whatsapper, Procrastinatorfrom enemies import Partial_Exam, Theoretical_Class, Teacher, Final_Examclass Game:    PLAYERS = 2    STAGE_LIMIT = 3    ENEMIES = 3    AVAILABLE_CHARACTERS = [Bookworn, Worker, Whatsapper, Procrastinator]    AVAILABLE_ENEMIES = [Partial_Exam, Theoretical_Class, Teacher, Final_Exam]    def __init__(self, file, stages, creator, id):        self.id = id        self.file = file        self.creator = creator        self.stages = stages        self.current_characters = []        self.client_sockets = []        self.players_info = []        self.enemies = []        self.current_stage = 1        self.players_are_alive = True        self.enemies_are_alive = True        self.turn = 0    @staticmethod    def print_current_stats(list_stats):        msg = ''        for element in list_stats:            msg += str(element) + "\n"        return msg    @staticmethod    def print_info():        msg = ''        for index, character_class in enumerate(Game.AVAILABLE_CHARACTERS):            msg += f'{index + 1}._'            msg += str(character_class()) + "\n"        return msg    @staticmethod    def display_characters(stages):        msg = ''        msg += f"A game with {stages} stages will be set up for two players" + "\n"        msg += "***********       AVAILABLE CHARACTERS         ***********" + "\n"        msg += Game.print_info()        msg += "**********************************************************"        return msg    @staticmethod    def print_players_turn():        msg = ''        msg += "        ----------------        " + "\n"        msg += "         PLAYERS TURN          " + "\n"        msg += "        ----------------        " + "\n"        return msg    @staticmethod    def create_character(n_character, hp):        if n_character == "Worker":            c = Worker()        elif n_character == "Procrastinator":            c = Procrastinator()        elif n_character == "Whatsapper":            c = Whatsapper()        elif n_character == "Bookworn":            c = Bookworn()        c.hp = hp        return c    def choose_character(self):        i = 1        while i <= Game.PLAYERS:            try:                number = int(input(f"Player {i}. Please, choose a character (1-4): "))                if 1 <= number <= len(Game.AVAILABLE_CHARACTERS):                    self.current_characters.append(Game.AVAILABLE_CHARACTERS[number - 1]())                else:                    raise ValueError                i += 1            except ValueError:                print("You've chosen an invalid value.")    def create_enemies(self):        if not self.enemies:            for i in range(Game.ENEMIES):                if self.current_stage < Game.STAGE_LIMIT:                    enemy = random.randint(0, Game.ENEMIES-1)                    self.enemies.append(Game.AVAILABLE_ENEMIES[enemy](self.current_stage))                else:                    enemy = random.randint(0, Game.ENEMIES)                    self.enemies.append(Game.AVAILABLE_ENEMIES[enemy](self.current_stage))    def print_chosen_ones(self):        msg = ''        msg += "**********************************************************" + "\n"        for index, player in enumerate(self.players_info):            msg += f"{index+1}._{player['name']}: "            msg += str(self.current_characters[index]) + "\n"        msg += "**********************************************************" + "\n"        return msg    def print_current_scenario(self):        self.create_enemies()        msg = ""        msg += "           *******************************            " + "\n"        msg += f"           *           STAGE {self.current_stage}           *" + "\n"        msg += "           *******************************            " + "\n"        msg += "-------------------------PLAYERS--------------------------" + "\n"        msg += str(self.print_current_stats(self.current_characters)) + "\n"        msg += "**********************************************************" + "\n"        msg += "--------------------CURRENT MONSTERS----------------------" + "\n"        msg += "**********************************************************" + "\n"        msg += str(self.print_current_stats(self.enemies)) + "\n"        msg += "**********************************************************" + "\n"        return msg    def both_players_are_dead(self):        yes_they_are = False        if not self.players_info[0]['alive'] and not self.players_info[1]['alive']:            yes_they_are = True        return yes_they_are    def check_characters_alive(self, alive_pc_index):        msg = ""        if self.current_characters[alive_pc_index].hp == 0:            msg += f'#The enemies have killed the {self.players_info[alive_pc_index]["character_name"]} '            msg += f'({self.players_info[alive_pc_index]["name"]}).' + "\n"            self.players_info[alive_pc_index]['alive'] = False            if self.both_players_are_dead():                self.players_are_alive = False                msg +='#All characters have been defeated. Try again.' + "\n"        return msg    def check_enemies_alive(self, enemy_choice):        msg = ""        if self.enemies[enemy_choice].hp == 0:            msg += f'The {self.enemies[enemy_choice].__class__.__name__} has been killed successfully.' + "\n"            msg += ' '            self.enemies.pop(enemy_choice)            if not self.enemies:                self.enemies_are_alive = False                msg += "#The players have killed all the enemies." + "\n"        return msg    def print_damage_done_by_player(self, enemy, damage):        msg = ""        msg += f'The {self.players_info[self.turn]["character_name"]} ({self.players_info[self.turn]["name"]}) did {damage} '        msg += f'damage to {self.enemies[enemy].__class__.__name__}. '        msg += f'{self.enemies[enemy].__class__.__name__} has {self.enemies[enemy].hp} hp left.' + "\n"        return msg    def print_damage_done_by_enemies(self, alive_pc_index, damage, enemy):        msg = ''        msg += f'The {enemy.__class__.__name__} did {damage} '        msg += f'damage to {self.current_characters[alive_pc_index].__class__.__name__} '        msg += f'({self.players_info[alive_pc_index]["name"]}). {self.current_characters[alive_pc_index].__class__.__name__} '        msg += f'has {self.current_characters[alive_pc_index].hp} hp left.' + "\n"        return msg    def attack_enemies(self):        enemy = random.randint(0, len(self.enemies)-1)        damage = self.current_characters[self.turn].attack(self.enemies[enemy])        return enemy, damage    def choice_alive_pc_index(self):        index = None        ok = False        while not ok:            index = random.randint(0, len(self.players_info) - 1)            if self.players_info[index]['alive']:                ok = True        return index    def attack_player(self, enemy):        alive_pc_index = self.choice_alive_pc_index()        character = self.current_characters[alive_pc_index]        damage = enemy.attack(character)        return alive_pc_index, damage    def player_attack(self):        msg = ''        enemy_choice, damage = self.attack_enemies()        msg += str(self.print_damage_done_by_player(enemy_choice, damage))        msg += str(self.check_enemies_alive(enemy_choice))        return msg    def enemies_turn(self):        i = 0        msg = ''        msg += "        ----------------        " + "\n"        msg += "         MONSTERS TURN          " + "\n"        msg += "        ----------------        " + "\n"        while i < len(self.enemies) and self.players_are_alive:            enemy = self.enemies[i]            alive_pc_index, damage = self.attack_player(enemy)            msg += str(self.print_damage_done_by_enemies(alive_pc_index, damage, enemy))            msg += str(self.check_characters_alive(alive_pc_index))            i += 1        return msg    def game_reaches_new_level(self):        msg = ''        if self.current_stage <= self.stages:            for i in range(len(self.current_characters)):                self.current_characters[i].increase_hp()            msg += "Every character alive have been healed 1/4 of his maximum health and the game has reached a new "            msg += "stage." + "\n"            msg += str(self.print_current_scenario())            self.enemies_are_alive = True        return msg    def set_turn(self):        ok = False        while not ok:            self.turn = (self.turn + 1) % Game.PLAYERS            if self.players_info[self.turn]['alive']:                ok = True            elif self.both_players_are_dead():                ok = True    def number_of_alive_players(self):        total = 0        for player in self.players_info:            if player['alive']:                total += 1        return total    def is_enemies_turn(self):        return self.enemies_are_alive and (self.number_of_alive_players() != Game.PLAYERS or self.turn == Game.PLAYERS-1)    def check_win(self, win):        if not self.players_are_alive:            win = False        elif not self.current_stage <= self.stages:            win = True        return win    def attack_action(self):        total_message = ''        win = None        if self.players_are_alive and self.current_stage <= self.stages:            total_message += self.player_attack()            if self.is_enemies_turn():                total_message += self.enemies_turn()                total_message += Game.print_players_turn()            elif not self.enemies_are_alive:                self.current_stage += 1                total_message += self.game_reaches_new_level()            self.set_turn()        win = self.check_win(win)        return total_message, win    def create_enemy(self, n_enemy, hp):        if n_enemy == "Partial_Exam":            e = Partial_Exam(self.current_stage)        elif n_enemy == "Final_Exam":            e = Final_Exam(self.current_stage)        elif n_enemy == "Theoretical_Class":            e = Theoretical_Class(self.current_stage)        elif n_enemy == "Teacher":            e = Teacher(self.current_stage)        e.hp = hp        return e    def load_enemies(self, dict_data):        for e in dict_data['enemies']:            self.enemies.append(self.create_enemy(e["type"], e["hp"]))    def load_characters(self, dict_data):        for index, c in enumerate(dict_data['current_characters']):            self.current_characters.append(Game.create_character(c["type"], c["hp"]))    def read_file(self):        with open(self.file) as f:            dict_data = json.loads(f.read())        self.stages = dict_data["stages"]        self.current_stage = dict_data["current_stage"]        self.players_info = dict_data['players_info']        self.load_characters(dict_data)        self.load_enemies(dict_data)        self.turn = dict_data['player_turn']    def save_players_info(self):        dict_data = []        for player in self.players_info:            dict_data.append({"name": player['name'],                              "alive": player['alive'],                              "character_name": player['character_name']})        return dict_data    def create_dict(self):        dict_data = {'player_turn': self.turn, 'current_stage': self.current_stage, 'stages': self.stages}        players = []        enemies = []        for player in self.current_characters:            players.append(player.dict_info())        for enemy in self.enemies:            enemies.append(enemy.dict_info())        dict_data['current_characters'] = players        dict_data['enemies'] = enemies        dict_data['players_info'] = self.save_players_info()        return dict_data    def save_file(self, file):        dict_data = self.create_dict()        with open(file, "w") as f:            f.write(json.dumps(dict_data))